<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: patterns | NatRitmeyer.com]]></title>
  <link href="http://natritmeyer.com/blog/categories/patterns/atom.xml" rel="self"/>
  <link href="http://natritmeyer.com/"/>
  <updated>2013-10-22T21:14:11+01:00</updated>
  <id>http://natritmeyer.com/</id>
  <author>
    <name><![CDATA[Nat Ritmeyer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A pattern for generating dynamic test data]]></title>
    <link href="http://natritmeyer.com/blog/2013/09/24/a-pattern-for-generating-dynamic-test-data/"/>
    <updated>2013-09-24T20:20:00+01:00</updated>
    <id>http://natritmeyer.com/blog/2013/09/24/a-pattern-for-generating-dynamic-test-data</id>
    <content type="html"><![CDATA[<p>When writing acceptance tests that use test data (and that&rsquo;s most of them), I like to deal with abstractions of that data rather than
the data itself. The reasons for this are:</p>

<ul>
<li>Using abstractions leads to more expressive tests: <code>@expired_account</code> instead of <code>77481</code> better relays the intent of the test to the reader</li>
<li>Using abstractions frees me from worrying about the details of the test data &ndash; no hard coded IDs!</li>
<li>Lack of hard coded data means that when something needs to change I only need to change it in one place, leading to more robust and maintainable code</li>
<li>Test code is code &ndash; it should adhere to all the usual best practices for coding; abstraction is one of them</li>
</ul>


<p>To illustrate this let&rsquo;s compare the following two chunks of code:</p>

<p><code>ruby
@bob = Human.new
AccountService.create_account_for @bob
AccountService.should have_account_for @bob
</code></p>

<p>&hellip;and&hellip;</p>

<p>```ruby
@name = &ldquo;Bob&rdquo;
@age = 50
@country = &ldquo;Botswana&rdquo;</p>

<p>AccountService.create_account_for @name, @age, @country</p>

<p>xml = AccountService.account_details_for_user_with_details @name, @age, @country
xml.at_xpath(&ldquo;//account/name&rdquo;).text.should == @name
xml.at_xpath(&ldquo;//account/name&rdquo;).text.should == @age
xml.at_xpath(&ldquo;//account/name&rdquo;).text.should == @country
```</p>

<p>Which one more quickly and clearly transmits the intent of the test to the reader? I&rsquo;d argue that the first does. The reader is not distracted with unnecessary details; instead they know they are creating a new generic <code>Human</code> object, creating an account with it and then verifying that the account has been created. The second one achieves the same thing but uses a lot more code &ndash; figuring out the intent of the test takes more time and effort; the result is less maintainable too.</p>

<p>It doesn&rsquo;t take much work to use test data abstractions like <code>Human</code> and what little work is required is paid back many, many, many times over. Eg: creating the above <code>Human</code> class is as simple as this:</p>

<p>```ruby
require &lsquo;builder&rsquo;</p>

<p>class Human
  attr_accessor :name
  attr_accessor :age
  attr_accessor :country</p>

<p>  def initialize</p>

<pre><code>@name = "Bob"
@age = 50
@country = "Botswana"
</code></pre>

<p>  end</p>

<p>  def to_xml</p>

<pre><code>b = Builder::XmlMarkup.new :indent =&gt; 2
b.instruct! :xml, :version =&gt; "1.0", :encoding =&gt; "utf-8"
b.Human do
  b.name @name
  b.age @age
  b.country @country
end
b.target!
</code></pre>

<p>  end
end
```</p>

<p>Let&rsquo;s take a look at what&rsquo;s going on.</p>

<p>The <code>initialize</code> method creates sensible default test data attributes when an instance of the <code>Human</code> class is created. The test data attributes are exposed using <code>attr_accessor</code>s so the test data object can be changed in the test. The <code>to_xml</code> method creates an XML representation of the human. This could just as well be a <code>to_json</code> method that spits out a json representation of the human*.</p>

<p><sub>
  * For those who take abstraction seriously this is a fine place to use the Template or Strategy patterns to decide between json and xml output at runtime.
</sub></p>

<p>Being able to create objects containing default test data that can be changed in the test will lead to more expressive test code (have I said that already?). Here&rsquo;s what I mean:</p>

<p><code>ruby
@baby = Human.new
@baby.age = 1
</code></p>

<p>The defaults, other than <code>age</code> are sensible, so we&rsquo;ll leave them. The only one we need to change is <code>age</code>, so we override the default value with <code>1</code>. Now that the <code>@baby</code> instance of <code>Human</code> has been created, when we see <code>@baby</code> in the test code it will read nicely:</p>

<p><code>ruby
AccountService.create_account_for(@baby).should == :too_young
</code></p>

<p>But still, it would be nice to not have to change the age of <code>@baby</code> in the test &ndash; why can&rsquo;t this happen automatically?</p>

<p>Well, by using the <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">Factory pattern</a> you can create specific instances of test data without cluttering up your test code. Factory classes are those that create instances of other classes, hiding any complicated setup. Eg:</p>

<p>```ruby
class HumanFactory
  def self.standard</p>

<pre><code>Human.new
</code></pre>

<p>  end</p>

<p>  def baby</p>

<pre><code>human = Human.new
human.age = 1
human
</code></pre>

<p>  end</p>

<p>  def self.too_old</p>

<pre><code>human = Human.new
human.age = 500
human.name = "Methuselah"
human
</code></pre>

<p>  end
end</p>

<h1>and to use the factory&hellip;</h1>

<p>@standard = HumanFactory.standard
@baby = HumanFactory.baby
@geriatric = HumanFactory.too_old
```</p>

<p>Thus far we are able to dynamically create objects that represent test data.</p>

<p>There is one more important thing in this pattern &ndash; the separation between the data and the representation of the data. When we call <code>to_xml</code>, we get back a string containing an XML representation of the test data object. What&rsquo;s this for? Well, in your tests you can use the output of the method to pass to services, etc &ndash; that&rsquo;s what the <code>AccountService.create_account_for(@baby)</code> example is doing &ndash; the <code>to_xml</code> method would be called inside the <code>create_account_for</code> method.</p>

<p>An essential attribute of the <code>to_xml</code> method is that however many times it is called, unless the data changes it should always return the same thing. For this reason the following would be bad:</p>

<p>```ruby
require &lsquo;builder&rsquo;
require &lsquo;active_support/time&rsquo;</p>

<p>class Human
  attr_accessor :birthday</p>

<p>  def initialize</p>

<pre><code>#@birthday not set to sensible default :(
</code></pre>

<p>  end</p>

<p>  def to_xml</p>

<pre><code>b = Builder::XmlMarkup.new :indent =&gt; 2
b.instruct! :xml, :version =&gt; "1.0", :encoding =&gt; "utf-8"
b.Human do
  b.birthday Time.now # &lt;-- this is bad!
end
b.target!
</code></pre>

<p>  end
end
```</p>

<p>The problem with the above is that in the <code>to_xml</code> method there is a call to something that will change every time it is called; <code>Time.now</code>. To illustrate the point here&rsquo;s what happens when you create an instance of the above class and call <code>to_xml</code> on it lots of times:</p>

<p><code>text
irb(main):030:0&gt; puts bob.to_xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Human&gt;
  &lt;birthday&gt;2013-09-24 21:35:14 +0100&lt;/birthday&gt;
&lt;/Human&gt;
=&gt; nil
irb(main):031:0&gt; puts bob.to_xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Human&gt;
  &lt;birthday&gt;2013-09-24 21:35:18 +0100&lt;/birthday&gt;
&lt;/Human&gt;
=&gt; nil
irb(main):032:0&gt; puts bob.to_xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Human&gt;
  &lt;birthday&gt;2013-09-24 21:35:25 +0100&lt;/birthday&gt;
&lt;/Human&gt;
=&gt; nil
</code></p>

<p>As you can see, every time we call <code>bob.to_xml</code> his birthday changes. Not great. Instead, the <code>to_xml</code> code should be changed so that all it has to worry about is <em>presenting</em> the data. Here&rsquo;s how to do it:</p>

<p>```ruby
require &lsquo;builder&rsquo;</p>

<p>class Human
  attr_accessor :birthday</p>

<p>  def initialize</p>

<pre><code>@birthday = Time.now
</code></pre>

<p>  end</p>

<p>  def to_xml</p>

<pre><code>b = Builder::XmlMarkup.new :indent =&gt; 2
b.instruct! :xml, :version =&gt; "1.0", :encoding =&gt; "utf-8"
b.Human do
  b.birthday @birthday.strftime "%Y-%m-%d"
end
b.target!
</code></pre>

<p>  end
end
```</p>

<p>This time, when we call <code>to_xml</code> a number of times, we&rsquo;ll see that as well as the data being static, it is also now presented correctly:</p>

<p><code>text
irb(main):054:0&gt; bob = Human.new
=&gt; #&lt;Human:0x007fc1c1d44d80 @birthday=2013-09-24 21:38:19 +0100&gt;
irb(main):055:0&gt; puts bob.to_xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Human&gt;
  &lt;birthday&gt;2013-09-24&lt;/birthday&gt;
&lt;/Human&gt;
=&gt; nil
irb(main):056:0&gt; puts bob.to_xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Human&gt;
  &lt;birthday&gt;2013-09-24&lt;/birthday&gt;
&lt;/Human&gt;
=&gt; nil
irb(main):057:0&gt; puts bob.to_xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Human&gt;
  &lt;birthday&gt;2013-09-24&lt;/birthday&gt;
&lt;/Human&gt;
=&gt; nil
</code></p>

<p>Summary:</p>

<ol>
<li>Create test data classes that represent types of test data you use in your acceptance tests (eg: <code>class Human</code>)</li>
<li>Expose attributes of those test data classes using accessors (eg: <code>attr_accessor :name</code>)</li>
<li>Set any attributes in the test data class to sensible defaults in the <code>initialize</code> method</li>
<li>Create <code>to_xml</code>/<code>to_json</code>/<code>to_csv</code>/etc rendering methods that will render the test data object in the formats required by your system under test</li>
<li>Ensure that rendering methods do not include any logic other than presentation logic</li>
<li>Use your test data classes in your test code</li>
<li>#win</li>
</ol>


<p>Hope that helps!</p>
]]></content>
  </entry>
  
</feed>
